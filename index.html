<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Geometry Laurea</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Pusab&display=swap'); /* Font stile GD (simile) */
        
        body { margin: 0; overflow: hidden; background-color: #202020; font-family: 'Arial', sans-serif; user-select: none; touch-action: none; }
        
        #game-container { position: relative; width: 100vw; height: 100vh; display: flex; align-items: center; justify-content: center; background: linear-gradient(180deg, #001f3f 0%, #000000 100%); }
        
        canvas { box-shadow: 0 0 50px rgba(0, 255, 255, 0.2); border-top: 5px solid #00ff41; border-bottom: 5px solid #00ff41; }

        /* BARRA PROGRESSO */
        #progress-container { position: absolute; top: 20px; width: 80%; height: 20px; background: rgba(255,255,255,0.1); border-radius: 10px; border: 2px solid white; z-index: 10; }
        #progress-bar { width: 0%; height: 100%; background: #00ff41; border-radius: 8px; transition: width 0.1s linear; }
        #percent-text { position: absolute; right: -50px; top: -5px; color: white; font-weight: bold; font-family: monospace; font-size: 20px; }

        /* UI */
        .ui-layer { position: absolute; width: 100%; height: 100%; display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 20; background: rgba(0,0,0,0.8); backdrop-filter: blur(5px); }
        
        h1 { color: #00ff41; font-size: 40px; text-transform: uppercase; margin-bottom: 10px; text-shadow: 0 0 10px #00ff41; text-align: center; }
        p { color: white; margin-bottom: 20px; text-align: center; max-width: 90%; }
        
        button { background: linear-gradient(45deg, #ff0000, #ff5500); border: none; padding: 15px 40px; color: white; font-size: 24px; font-weight: bold; border-radius: 50px; cursor: pointer; box-shadow: 0 10px 20px rgba(255, 0, 0, 0.4); transition: transform 0.1s; }
        button:active { transform: scale(0.95); }

        .hidden { display: none !important; }

        /* CLASSIFICA */
        #leaderboard-box { background: rgba(255,255,255,0.1); width: 80%; max-width: 400px; padding: 15px; border-radius: 10px; max-height: 200px; overflow-y: auto; text-align: left; }
        .row { display: flex; justify-content: space-between; padding: 5px 0; border-bottom: 1px solid rgba(255,255,255,0.2); color: #ddd; }
        .row:first-child { color: gold; font-weight: bold; }
        
        input { padding: 15px; font-size: 20px; text-align: center; border-radius: 10px; border: none; margin-bottom: 20px; width: 80%; max-width: 300px; }

        /* SFONDO DINAMICO */
        .bg-particles { position: absolute; top:0; left:0; width:100%; height:100%; pointer-events: none; z-index: 0; opacity: 0.3; }
    </style>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-app.js";
        import { getDatabase, ref, push, query, orderByChild, limitToLast, onValue } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-database.js";

        // --- INCOLLA QUI LA TUA CONFIGURAZIONE ---
        const firebaseConfig = {
          apiKey: "INCOLLA_LA_TUA_API_KEY",
          authDomain: "laurea-4270d.firebaseapp.com",
          databaseURL: "https://laurea-4270d-default-rtdb.europe-west1.firebasedatabase.app",
          projectId: "laurea-4270d",
          storageBucket: "laurea-4270d.firebasestorage.app",
          messagingSenderId: "351839726503",
          appId: "1:351839726503:web:fcc110de03f49822bde482"
        };
        // -----------------------------------------

        const app = initializeApp(firebaseConfig);
        const db = getDatabase(app);

        // Salva punteggio (Percentuale completata o Tempo se 100%)
        window.saveScoreToDb = function(name, percent) {
            push(ref(db, 'geo_scores'), { name: name, score: percent, date: Date.now() });
        };

        // Carica Classifica
        window.loadLeaderboard = function() {
            const q = query(ref(db, 'geo_scores'), orderByChild('score'), limitToLast(10));
            onValue(q, (snapshot) => {
                const list = document.getElementById('lb-list');
                list.innerHTML = "";
                let data = [];
                snapshot.forEach(c => data.push(c.val()));
                data.sort((a,b) => b.score - a.score); // Dal piÃ¹ alto al piÃ¹ basso
                
                if(data.length === 0) list.innerHTML = "<div>Nessun punteggio</div>";
                
                data.forEach((entry, i) => {
                    const d = document.createElement('div');
                    d.className = 'row';
                    // Se ha fatto 100, metti una corona
                    let displayScore = entry.score >= 100 ? "ðŸ‘‘ COMPLETATO" : entry.score + "%";
                    d.innerHTML = `<span>${i+1}. ${entry.name.substring(0,10)}</span><span>${displayScore}</span>`;
                    list.appendChild(d);
                });
            });
        };
        loadLeaderboard();
    </script>
</head>
<body>

    <div id="progress-container">
        <div id="progress-bar"></div>
        <div id="percent-text">0%</div>
    </div>

    <div id="game-container">
        <canvas id="gameCanvas"></canvas>

        <div id="start-screen" class="ui-layer">
            <h1>Geometry Laurea</h1>
            <p>Tocca per saltare. Tieni premuto per salti consecutivi.<br>Arriva al 100% per leggere il messaggio finale.</p>
            <button onclick="startGame()">START LEVEL 1</button>
            <div id="leaderboard-box" style="margin-top: 20px;">
                <div style="text-align:center; color:#00ff41; border-bottom:1px solid #555; margin-bottom:10px;">TOP PLAYERS</div>
                <div id="lb-list">Loading...</div>
            </div>
        </div>

        <div id="win-screen" class="ui-layer hidden">
            <h1>LIVELLO COMPLETATO!</h1>
            <p style="font-size: 18px; line-height: 1.6;">
                "L'informatica non riguarda i computer piÃ¹ di quanto l'astronomia riguardi i telescopi."<br><br>
                Grazie per aver condiviso questo traguardo con me.<br>
                <i>- Riccardo</i>
            </p>
            <input type="text" id="winner-name" placeholder="Il tuo nome" maxlength="12">
            <button onclick="submitWin()">ENTRA NELLA STORIA</button>
        </div>

        <div id="lose-screen" class="ui-layer hidden">
            <h1 style="color:red">CRASH!</h1>
            <p>Sei arrivato al <span id="final-percent" style="font-weight:bold; color:white">0%</span></p>
            <button onclick="resetGame()">RIPROVA</button>
            <br>
            <p style="font-size:12px; margin-top:10px; opacity:0.7;">Non arrenderti, Ã¨ solo un bug.</p>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const imgFace = new Image();
        imgFace.src = 'face.png'; // L'immagine che carichi su GitHub

        // SETUP CANVAS
        function resize() {
            canvas.width = Math.min(window.innerWidth, 800);
            canvas.height = Math.min(window.innerHeight, 400);
        }
        window.addEventListener('resize', resize);
        resize();

        // GAME CONFIG
        const GRAVITY = 0.6;
        const JUMP_FORCE = -10.5; // Salto secco
        const SPEED = 6;
        const LEVEL_LENGTH = 3000; // Lunghezza del livello in pixel

        let state = {
            running: false,
            frame: 0,
            distance: 0,
            player: { x: 100, y: 200, dy: 0, size: 40, rotation: 0, grounded: false },
            obstacles: [],
            particles: [] // Per effetto esplosione
        };

        // INPUT
        let inputActive = false;
        function jump() {
            if(!state.running) return;
            if(state.player.grounded) {
                state.player.dy = JUMP_FORCE;
                state.player.grounded = false;
            }
        }
        
        window.addEventListener('mousedown', () => { inputActive = true; jump(); });
        window.addEventListener('mouseup', () => { inputActive = false; });
        window.addEventListener('touchstart', (e) => { e.preventDefault(); inputActive = true; jump(); }, {passive: false});
        window.addEventListener('touchend', () => { inputActive = false; });
        window.addEventListener('keydown', (e) => { if(e.code==='Space') { inputActive = true; jump(); } });
        window.addEventListener('keyup', () => { inputActive = false; });

        function startGame() {
            document.getElementById('start-screen').classList.add('hidden');
            resetVariables();
            state.running = true;
            loop();
        }

        function resetVariables() {
            state.player.y = canvas.height - 100;
            state.player.dy = 0;
            state.player.rotation = 0;
            state.distance = 0;
            state.obstacles = [];
            state.frame = 0;
            // Genera il livello (Ostacoli procedurali ma sempre uguali per tutti)
            generateLevel();
        }

        function generateLevel() {
            // Genera ostacoli ogni X pixel
            for(let i=500; i<LEVEL_LENGTH; i+= 400) { // Distanza tra ostacoli
                // Randomizza leggermente la posizione ma mantieni ritmo
                let noise = Math.random() * 100;
                // Ostacolo triangolare (Spike)
                state.obstacles.push({ x: i + noise, type: 'spike' });
                
                // A volte aggiungi un blocco da saltare sopra
                if(Math.random() > 0.7) {
                    state.obstacles.push({ x: i + noise + 200, type: 'block' });
                }
            }
        }

        function resetGame() {
            document.getElementById('lose-screen').classList.add('hidden');
            resetVariables();
            state.running = true;
            loop();
        }

        function loop() {
            if(!state.running) return;
            requestAnimationFrame(loop);
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // 1. UPDATE PLAYER
            state.player.dy += GRAVITY;
            state.player.y += state.player.dy;

            // Pavimento
            let groundY = canvas.height - 50;
            if(state.player.y + state.player.size > groundY) {
                state.player.y = groundY - state.player.size;
                state.player.dy = 0;
                state.player.grounded = true;
                // Arrotonda rotazione a terra (stile Geometry Dash)
                let nearest90 = Math.round(state.player.rotation / (Math.PI/2)) * (Math.PI/2);
                state.player.rotation = nearest90;
            } else {
                // Ruota mentre salta
                state.player.rotation += 0.15; 
            }

            // Salto continuo se tieni premuto (opzionale, Geometry Dash di solito Ã¨ tap, ma qui aiuta)
            if(inputActive && state.player.grounded) {
                jump();
            }

            // 2. UPDATE PROGRESS
            state.distance += SPEED;
            let percent = Math.min(100, Math.floor((state.distance / LEVEL_LENGTH) * 100));
            document.getElementById('progress-bar').style.width = percent + "%";
            document.getElementById('percent-text').innerText = percent + "%";

            // WIN CONDITION
            if(state.distance >= LEVEL_LENGTH) {
                winGame();
                return;
            }

            // 3. DRAW SCENE
            // Sfondo griglia stile GD
            ctx.fillStyle = '#111';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.beginPath();
            for(let x = -(state.distance % 50); x < canvas.width; x+=50) { ctx.moveTo(x,0); ctx.lineTo(x,canvas.height); }
            for(let y = 0; y < canvas.height; y+=50) { ctx.moveTo(0,y); ctx.lineTo(canvas.width,y); }
            ctx.stroke();

            // Pavimento (Linea verde neon)
            ctx.fillStyle = '#00ff41';
            ctx.fillRect(0, groundY, canvas.width, 5);

            // PLAYER (La tua faccia che ruota)
            ctx.save();
            ctx.translate(state.player.x + state.player.size/2, state.player.y + state.player.size/2);
            ctx.rotate(state.player.rotation);
            ctx.drawImage(imgFace, -state.player.size/2, -state.player.size/2, state.player.size, state.player.size);
            // Bordo neon attorno alla faccia
            ctx.strokeStyle = '#ffff00';
            ctx.lineWidth = 3;
            ctx.strokeRect(-state.player.size/2, -state.player.size/2, state.player.size, state.player.size);
            ctx.restore();

            // 4. OSTACOLI
            ctx.fillStyle = '#ff0040'; // Colore spine
            
            for(let obs of state.obstacles) {
                let screenX = obs.x - state.distance + 150; // +150 offset iniziale
                
                if(screenX > -50 && screenX < canvas.width + 50) {
                    if(obs.type === 'spike') {
                        // Disegna triangolo
                        ctx.beginPath();
                        ctx.moveTo(screenX, groundY);
                        ctx.lineTo(screenX + 20, groundY - 40); // Punta
                        ctx.lineTo(screenX + 40, groundY);
                        ctx.fill();
                        
                        // COLLISIONE (Hitbox semplice)
                        if(checkRectCollision(state.player.x, state.player.y, state.player.size, state.player.size, screenX + 10, groundY - 30, 20, 30)) {
                            gameOver(percent);
                        }
                    } else if (obs.type === 'block') {
                         ctx.fillStyle = '#00ffff';
                         ctx.fillRect(screenX, groundY - 40, 40, 40);
                         // Collisione blocco
                         if(checkRectCollision(state.player.x, state.player.y, state.player.size, state.player.size, screenX, groundY - 40, 40, 40)) {
                            gameOver(percent);
                        }
                        ctx.fillStyle = '#ff0040'; // reset colore
                    }
                }
            }
        }

        function checkRectCollision(x1, y1, w1, h1, x2, y2, w2, h2) {
            return (x1 < x2 + w2 && x1 + w1 > x2 && y1 < y2 + h2 && y1 + h1 > y2);
        }

        function gameOver(percent) {
            state.running = false;
            // Salva solo se Ã¨ un buon punteggio (opzionale, qui salviamo sempre per la classifica)
            // Se vuoi salvare anche chi perde: window.saveScoreToDb("Anonimo", percent);
            
            document.getElementById('final-percent').innerText = percent + "%";
            document.getElementById('lose-screen').classList.remove('hidden');
        }

        function winGame() {
            state.running = false;
            document.getElementById('win-screen').classList.remove('hidden');
        }

        window.submitWin = function() {
            const name = document.getElementById('winner-name').value.trim();
            if(!name) return alert("Inserisci il nome!");
            
            // Salva 100% nel database
            window.saveScoreToDb(name, 100);
            alert("Punteggio salvato! Sei un mito.");
            location.reload();
        }

    </script>
</body>
</html>
